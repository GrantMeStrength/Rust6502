
 mod memory;
 mod cpu;

 use std::io;
 use std::io::Write;
 use std::thread;
 use std::time;
 
 use termion;
 use termion::input::TermRead;
 use termion::raw::IntoRawMode;

 
 pub fn main()  {

	// The 6502 side is all well and good, but it's more interesting when it can 
	// read the keyboard and interact with it as it's running the Apple-1 ROM code.
	// The issue is that there is no easy way to scan for keypresses in a simple 
	// terminal window.  So, we need to use a library that can do this for us.
	// I'm looking for the right one.  
  
	 // Set terminal to raw mode to allow reading stdin one key at a time
	 let mut stdout = io::stdout().into_raw_mode().unwrap();

	 // Use asynchronous stdin
	 let mut stdin = termion::async_stdin().keys();


	println!("6502 Startup");

	// 6502 Implementation
	println!("6502 initializer");
	let mut cpu6502 : cpu::Cpu = cpu::Cpu::new();
	
	println!("Resetting 6502...");
	cpu6502.reset();

	println!("Loading some data into memory - it's WozMon!");
	cpu6502.load_data_into_memory(0xff00, vec![0xD8, 0x58, 0xA0, 0x7F, 0x8C, 0x12, 0xD0, 0xA9, 0xA7, 0x8D, 0x11, 0xD0, 0x8D, 0x13, 0xD0, 0xC9, 0xDF, 0xF0, 0x13, 0xC9, 0x9B, 0xF0, 0x03, 0xC8, 0x10, 0x0F, 0xA9, 0xDC, 0x20, 0xEF, 0xFF, 0xA9, 0x8D, 0x20, 0xEF, 0xFF, 0xA0, 0x01, 0x88, 0x30, 0xF6, 0xAD, 0x11, 0xD0, 0x10, 0xFB, 0xAD, 0x10, 0xD0, 0x99, 0x00, 0x02, 0x20, 0xEF, 0xFF, 0xC9, 0x8D, 0xD0, 0xD4, 0xA0, 0xFF, 0xA9, 0x00, 0xAA, 0x0A, 0x85, 0x2B, 0xC8, 0xB9, 0x00, 0x02, 0xC9, 0x8D, 0xF0, 0xD4, 0xC9, 0xAE, 0x90, 0xF4, 0xF0, 0xF0, 0xC9, 0xBA, 0xF0, 0xEB, 0xC9, 0xD2, 0xF0, 0x3B, 0x86, 0x28, 0x86, 0x29, 0x84, 0x2A, 0xB9, 0x00, 0x02, 0x49, 0xB0, 0xC9, 0x0A, 0x90, 0x06, 0x69, 0x88, 0xC9, 0xFA, 0x90, 0x11, 0x0A, 0x0A, 0x0A, 0x0A, 0xA2, 0x04, 0x0A, 0x26, 0x28, 0x26, 0x29, 0xCA, 0xD0, 0xF8, 0xC8, 0xD0, 0xE0, 0xC4, 0x2A, 0xF0, 0x97, 0x24, 0x2B, 0x50, 0x10, 0xA5, 0x28, 0x81, 0x26, 0xE6, 0x26, 0xD0, 0xB5, 0xE6, 0x27, 0x4C, 0x44, 0xFF, 0x6C, 0x24, 0x00, 0x30, 0x2B, 0xA2, 0x02, 0xB5, 0x27, 0x95, 0x25, 0x95, 0x23, 0xCA, 0xD0, 0xF7, 0xD0, 0x14, 0xA9, 0x8D, 0x20, 0xEF, 0xFF, 0xA5, 0x25, 0x20, 0xDC, 0xFF, 0xA5, 0x24, 0x20, 0xDC, 0xFF, 0xA9, 0xBA, 0x20, 0xEF, 0xFF, 0xA9, 0xA0, 0x20, 0xEF, 0xFF, 0xA1, 0x24, 0x20, 0xDC, 0xFF, 0x86, 0x2B, 0xA5, 0x24, 0xC5, 0x28, 0xA5, 0x25, 0xE5, 0x29, 0xB0, 0xC1, 0xE6, 0x24, 0xD0, 0x02, 0xE6, 0x25, 0xA5, 0x24, 0x29, 0x07, 0x10, 0xC8, 0x48, 0x4A, 0x4A, 0x4A, 0x4A, 0x20, 0xE5, 0xFF, 0x68, 0x29, 0x0F, 0x09, 0xB0, 0xC9, 0xBA, 0x90, 0x02, 0x69, 0x06, 0x2C, 0x12, 0xD0, 0x30, 0xFB, 0x8D, 0x12, 0xD0, 0x60, 0x00, 0x00, 0x00, 0x0F, 0x00, 0xFF, 0x00, 0x00]);


	println!("Executing code");
	

	// Keep doing this until you're bored.
	loop {

		let input = stdin.next();

	 // If a key was pressed
	 if let Some(Ok(key)) = input {
		match key {
			// Exit if 'q' is pressed
			termion::event::Key::Char('q') => break,
			// Else print the pressed key
			_ => {
				write!(
					stdout,
					"{}{}Key pressed: {:?}",
					termion::clear::All,
					termion::cursor::Goto(1, 1),
					key
				)
				.unwrap();

				stdout.lock().flush().unwrap();
			}
		}
	}
	thread::sleep(time::Duration::from_millis(50));

	cpu6502.execute(); 
	// write!(stdout,"plop",
	// termion::cursor::Goto(10, 1), "plop"
	// //cpu6502.print_cpu_status_on_one_line();
	// )
}

	


	

	println!("Program ended");

}
